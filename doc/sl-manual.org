# -*- fill-column: 72; -*-
#+TITLE: SL Manual
#+AUTHOR: 8dcc
#+OPTIONS: toc:2
#+STARTUP: nofold
#+TEXINFO_DIR_CATEGORY: Software development

#+TOC: headlines 2

Manual for [[https://github.com/8dcc/sl][8dcc/sl]].

* Constants

These constants are defined by default in the global environment.

#+begin_comment
TODO: Org fails to export variables named "nil", so we need to add
quotes until it's fixed.

https://list.orgmode.org/878qvbstna.fsf@gmail.com/T/#u
#+end_comment

- Variable: `nil' ::

  Represents the empty list, but is also used to denote /false/ in
  procedures returning predicates.

  #+begin_src lisp
  > nil
  nil

  > '()
  nil

  > ()  ; Special case, not treated as function call
  nil

  > (eval nil)
  nil

  > (cons 1 (cons 2 nil))
  (1 2)
  #+end_src

- Variable: `tru' ::

  Symbol that evaluates to itself, used for representing explicit truth
  in procedures returning predicates. There is no need for this symbol,
  since any non-nil expression represents truth, but it's convenient.

  #+begin_src lisp
  > tru
  tru

  > (eval tru)
  tru
  #+end_src

* Primitive Procedures

This section explains the different primitive procedures in
SL. Primitive procedures are implemented in C.

** Special Forms

These primitives are /special forms/, that is, special procedures whose
arguments are /not/ evaluated before the call. This way the procedures can
operate on the un-evaluated expressions, before evaluating them manually
if needed. The C primitives for this section are defined in
[[file:prim_special.c]].

A list is interpreted as a special form call when its first element is a
special form symbol. The list of special form symbols is defined in
[[file:eval.c]], so they are hard-coded into the interpreter.

#+begin_src lisp
(define special-form-symbols
    (list ...))

(defun is-special-form (e)
  ;; Non-empty list whose first element is a special symbol.
  (and (list? e)
       (not (null? e))
       (symbol? (car e))
       (member? (car e) special-form-symbol)))
#+end_src

However, since the actual functions corresponding to the special form
symbols are retrieved normally from the current environment, it is
/technically/ possible to overwrite the symbols with new functions
(e.g. using =define=), but it's highly discouraged.

For more information on special forms, see Section 4.1.1 of /Structure
and Interpretation of Computer Programs/[fn::
[[https://web.mit.edu/6.001/6.037/sicp.pdf#subsection.4.1.1]]].

- Special Form: quote expr ::

  Return the argument, effectively delaying its evaluation.

  #+begin_src lisp
  > (quote x)
  x

  > 'x
  x

  > (quote (+ 1 2))
  (+ 1 2)
  #+end_src

  Note that ='expr= is just syntactic sugar for =(quote expr)=. This is
  handled in [[file:parser.c]].

- Special Form: define symbol expr ::

  Bind symbol to a value in the current environment.

  Evaluates the second argument, and binds it to the first one. Returns
  the evaluated expression.

  #+begin_src lisp
  > n
  Unbound symbol: n

  > (define n 123)
  123

  > n
  123
  #+end_src

  As mentioned, it only operates on the /current/ environment.

  #+begin_src lisp
  > (define n 123)
  123

  > (define f
      (lambda ()
        (define n 999)
        (list "Finished:" n)))
  <lambda>

  > (f)
  ("Finished:" 999)

  > n
  123
  #+end_src

  It is a special form because the first argument is not evaluated. This
  way, it doesn't have to be quoted by the caller.

- Special Form: define-global symbol expr ::

  Bind symbol to a value in the top-most environment. See the =define=
  special form for more information.

  #+begin_src lisp
  > (define n 123)
  123

  > (define f
      (lambda ()
        (define-global n 999)
        (list "Finished:" n)))
  <lambda>

  > (f)
  ("Finished:" 999)

  > n
  999
  #+end_src

- Special Form: lambda formals body... ::

  Return a new anonymous procedure.

  The =lambda= primitive expects a list of formal arguments (which must be
  symbols) and one or more expressions (of any type) for the body.

  Expressions of type /Lambda/ evaluate to themselves. When calling a
  lambda, each argument is evaluated and bound to its formal symbol, and
  each expression in the body of the function is evaluated in order,
  returning the last one.

  #+begin_src lisp
  > (lambda (x)
      (* x 3))
  <lambda>

  > ((lambda (x) (* x 3)) 5)
  15

  > (define f
      (lambda (x)
        (+ x 5)))
  <lambda>

  > (f 3)
  8
  #+end_src

  A keyword symbol =&rest= followed by a single symbol /S/, can be used in
  the formal argument list to indicate that the caller can provide extra
  non-mandatory arguments, and they will be stored in a *list* bound to
  the symbol /S/ when making the call. If no extra arguments are provided
  when making the call, /S/ is bound to the empty list =nil=.

  #+begin_src lisp
  > (define f
      (lambda (a b &rest other)
        (list a b other)))
  <lambda>

  > (f 1 2 3 4 5)
  (1 2 (3 4 5))
  #+end_src

- Special Form: macro formals body... ::

  Return a new anonymous macro.

  The =macro= primitive expects a list of formal arguments (which must be
  symbols) and one or more expressions (of any type) for the body.

  Expressions of type /Macro/ evaluate to themselves. Macros are generally
  similar to lambdas, but there are some key differences:

  - When a macro is called, the arguments are *not* evaluated before
    applying it, so the macro can operate on the un-evaluated
    expressions directly, instead of on the values they compute. The
    first step of a macro call is binding the un-evaluated arguments to
    the formals.
  - Macros don't /directly/ compute values, they instead build Lisp
    expressions that will be used to compute the actual values. The
    second step of a macro call is the /macro expansion/ (see
    [[*General Primitives]]). In this step, the macro is called just like a
    lambda, returning a Lisp expression.
  - The last step of a macro call is evaluating the expanded expression,
    which will be used to compute the actual value returned by the
    macro.

  In other words the general process when calling a lambda is:

  #+begin_example
  Evaluate arguments -> Bind arguments -> Evaluate body
                        `-----------------------------´
                                   (Apply)
  #+end_example

  While the call process of a macro is:

  #+begin_example
  Bind arguments -> Evaluate body -> Evaluate expansion
  `-----------------------------´
              (Expand)
  #+end_example

  While the process of calling a macro is:

  #+begin_src lisp
  > (macro (name) (list 'define name 123))
  <macro>

  > (define my-macro
      (macro (name) (list 'define name 123)))
  <macro>

  > (my-macro some-name)
  123

  > (macroexpand '(my-macro some-name))
  (define some-name 123)

  > some-name
  123
  #+end_src

  In the previous example, notice how we don't have to quote =some-name=
  when calling =my-macro=. This is because, since macro arguments are not
  evaluated, the /symbol/ =some-name= is passed to the macro, not the value
  bound to it. The macro is expanded to the list =(define some-name 123)=,
  and then it's evaluated.

  Just like lambdas, macros support the use of the =&rest= keyword in the
  formal argument list.

  For more information on how macros behave in this Lisp, see the
  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Macros.html][Emacs Lisp manual]].

- Special Form: begin &rest exprs ::

  Evaluate each argument in order, and return the last result.

  This primitive is a special form for various reasons. When making a
  normal procedure call, the arguments are not required to be evaluated
  in order, when calling =begin=, they are. The fact that it has to
  evaluate the expressions is helpful when combined with something like
  =apply= and a quoted expression (see [[*General Primitives]]).

  #+begin_src lisp
  ;; Arguments not evaluated because it's a special form.
  > (begin
     (define n 123)
     (+ 1 2))
  3

  > n
  123

  ;; Arguments not evaluated because the list is quoted.
  > (apply begin
           '((define n 456)
             (+ 1 2)))
  3

  > n
  456
  #+end_src

- Special Form: if predicate consequent alternative ::

  Return evaluated /consequent/ or /alternative/ depending on whether or not
  /predicate/ evaluated to non-nil or not, respectively.

  #+begin_src lisp
  > (if tru 'abc 'xyz)
  abc

  > (if nil 'abc 'xyz)
  xyz

  > (if (> 5 3)
        (+ 10 20)
        (- 60 50))
  30
  #+end_src

  Note that the /predicate/ is always evaluated, but only the /consequent/
  or the /alternative/ is evaluated afterwards. This is a good example on
  why special forms are necessary, since a normal function call would
  have to evaluate the 3 arguments before applying =if= to them.

- Special Form: or &rest exprs ::

  Evaluates each argument expression in order, and once it finds a
  non-nil result, it stops evaluating and returns it. Returns =nil= if all
  of them evaluated to =nil=, or when called with no arguments.

  #+begin_src lisp
  > (or (> 1 2) (> 3 4) (> 5 6))
  nil

  > (or (> 1 2) (> 3 4) 'hello)
  hello

  > (or)
  nil
  #+end_src

  Note that this primitive does not need to be a special form, since it
  can be built with a macro and =if=.

  #+begin_src lisp
  (defmacro my-or (&rest exprs)
    (if (null? exprs)
        nil
        ;; TODO: Don't overwrite "result", generate unique symbol.
        (list (list 'lambda (list 'result)
                    (list 'if
                          'result
                          'result
                          (cons 'my-or (cdr exprs))))
              (car exprs))))
  #+end_src

- Special Form: and &rest exprs ::

  Evaluates each argument expression in order, and if it finds a =nil=
  result, it stops evaluating and returns =nil=. If all arguments
  evaluated to non-nil, returns the last result. Returns =tru= when called
  with no arguments.

  #+begin_src lisp
  > (and (> 1 2) (> 3 4) (> 5 6))
  nil

  > (and (> 4 3) (> 2 1) 'hello)
  hello

  > (and)
  tru
  #+end_src

  Just like with =or=, this primitive does not need to be a special form:

  #+begin_src lisp
  (defmacro my-and (&rest exprs)
    (if (null? exprs)
        tru
        ;; TODO: Don't overwrite "result", generate unique symbol.
        (list (list 'lambda (list 'result)
                    (list 'if
                          'result
                          (if (null? (cdr exprs))
                              'result
                              (cons 'my-and (cdr exprs)))
                          nil))
              (car exprs))))
  #+end_src

** General Primitives

These primitives don't fit into other categories. They are defined in
[[file:prim_general.c]].

- Function: eval expr ::

  Evaluate the specified expression.

  Different expression types have different evaluation rules:

  1. The empty list (=nil=) evaluates to itself.
  2. Non-empty lists are evaluated as procedure calls.
     - If the (un-evaluated) =car= of the list is a special form symbol
       (see [[*Special Forms]]), it passes the un-evaluated =cdr= to the
       corresponding special form primitive.
     - If the (evaluated) =car= of the list is a macro, the macro is
       called with the un-evaluated =cdr= of the list.
     - Otherwise, the arguments are evaluated and the procedure is
       called. If one argument fails to evaluate, evaluation stops.
  3. Symbols evaluate to their bound values in the current
     environment[fn::See also Section 3.2 of SICP.].
  4. Other expression types (numbers, strings, functions, etc.)
     evaluate to themselves.

  Keep in mind that, since =eval= is a normal procedure, its arguments
  will be evaluated before the actual function call is made, so the user
  might need to use the =quote= special form.

  #+begin_src lisp
  (define var 123)

  ;; We are evaluating 123, which evaluates to itself.
  (eval var)

  ;; We are evaluating the symbol "var", which evaluates to 123.
  (eval (quote var))
  #+end_src

  The C /primitive/ is called =prim_eval=, but the actual evaluation process
  is performed by the C function =eval=, defined in [[file:eval.c]].

- Function: apply function arg-list ::

  Apply a function to a list of arguments.

  The first argument must be an /applicable/ expression, that is, a
  /Primitive/, /Lambda/ or /Macro/; and the second argument must be a list.

  Again, =apply= is a normal procedure, so its arguments will be evaluated
  before the call. However, even thought the user might need to quote
  the argument list, the first argument must be a /procedure/, not a
  /symbol/.

  #+begin_src lisp
  > (apply '+ '(1 2 3))
  Error: Expected a procedure as the first argument, got 'Symbol'.

  > (apply + '(1 2 3))
  6
  #+end_src

  Just like with =eval=, the C /primitive/ is called =prim_apply=, but it's
  just a wrapper for the C function =apply=, defined in [[file:eval.c]]. It
  checks the type of the =function= expression, and dispatches the call to
  the appropriate function for performing the actual application process
  (e.g. =lambda_call=). For more information, see =lambda= and =macro= in
  [[*Special Forms][Special Forms]].

- Function: macroexpand quoted-expr ::

  TODO
